<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Arturo Torres Ortiz">
<meta name="dcterms.date" content="2026-01-13">

<title>Assignment 1: Next Generation Sequencing Technologies – TRGN 515</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-38685b6e60ad7588714dbe24fc7031b2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">TRGN 515</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../modules.html"> 
<span class="menu-text">Modules</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/trgn-515"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../modules/1_sequencing_techs/1_sequencing_techs.html">Module 1: Sequencing technologies</a></li><li class="breadcrumb-item"><a href="../../modules/1_sequencing_techs/1_sequencing_techs.html">Assignment 1: Next Generation Sequencing Technologies</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Module 1: Sequencing technologies</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../modules/1_sequencing_techs/1_sequencing_techs.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Assignment 1: Next Generation Sequencing Technologies</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link active" data-scroll-target="#learning-objectives">Learning objectives</a></li>
  <li><a href="#input-and-outputs" id="toc-input-and-outputs" class="nav-link" data-scroll-target="#input-and-outputs">Input and outputs</a></li>
  <li><a href="#required-software" id="toc-required-software" class="nav-link" data-scroll-target="#required-software">Required software</a></li>
  <li><a href="#manipulating-fastq-files" id="toc-manipulating-fastq-files" class="nav-link" data-scroll-target="#manipulating-fastq-files">Manipulating Fastq files</a>
  <ul class="collapse">
  <li><a href="#task-1-compare-raw-read-statistics-between-sequencing-technologies" id="toc-task-1-compare-raw-read-statistics-between-sequencing-technologies" class="nav-link" data-scroll-target="#task-1-compare-raw-read-statistics-between-sequencing-technologies">Task 1: Compare raw read statistics between sequencing technologies</a></li>
  </ul></li>
  <li><a href="#oxford-nanopore-output-files" id="toc-oxford-nanopore-output-files" class="nav-link" data-scroll-target="#oxford-nanopore-output-files">Oxford Nanopore output files</a></li>
  <li><a href="#quality-check" id="toc-quality-check" class="nav-link" data-scroll-target="#quality-check">Quality Check</a>
  <ul class="collapse">
  <li><a href="#quality-check-for-short-reads---fastqc" id="toc-quality-check-for-short-reads---fastqc" class="nav-link" data-scroll-target="#quality-check-for-short-reads---fastqc">Quality check for short-reads - FastQC</a></li>
  <li><a href="#quality-check-for-long-reads" id="toc-quality-check-for-long-reads" class="nav-link" data-scroll-target="#quality-check-for-long-reads">Quality check for long-reads</a>
  <ul class="collapse">
  <li><a href="#task-2-run-fastqc-on-illumina-reads" id="toc-task-2-run-fastqc-on-illumina-reads" class="nav-link" data-scroll-target="#task-2-run-fastqc-on-illumina-reads">Task 2: Run FastQC on Illumina reads</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#quality-control-qc" id="toc-quality-control-qc" class="nav-link" data-scroll-target="#quality-control-qc">Quality Control (QC)</a>
  <ul class="collapse">
  <li><a href="#qc-for-short-reads---trimmomatic" id="toc-qc-for-short-reads---trimmomatic" class="nav-link" data-scroll-target="#qc-for-short-reads---trimmomatic">QC for short-reads - Trimmomatic</a>
  <ul class="collapse">
  <li><a href="#task-3-run-fastqc-after-running-trimmomatic" id="toc-task-3-run-fastqc-after-running-trimmomatic" class="nav-link" data-scroll-target="#task-3-run-fastqc-after-running-trimmomatic">Task 3: Run FastQC after running Trimmomatic</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#qc-of-long-reads" id="toc-qc-of-long-reads" class="nav-link" data-scroll-target="#qc-of-long-reads">QC of long reads</a>
  <ul class="collapse">
  <li><a href="#task-4-long-read-qc" id="toc-task-4-long-read-qc" class="nav-link" data-scroll-target="#task-4-long-read-qc">Task 4: Long read QC</a></li>
  </ul></li>
  <li><a href="#read-mapping-to-a-reference-genome" id="toc-read-mapping-to-a-reference-genome" class="nav-link" data-scroll-target="#read-mapping-to-a-reference-genome">Read mapping to a reference genome</a>
  <ul class="collapse">
  <li><a href="#short-read-mapping" id="toc-short-read-mapping" class="nav-link" data-scroll-target="#short-read-mapping">Short-read mapping</a>
  <ul class="collapse">
  <li><a href="#bwa" id="toc-bwa" class="nav-link" data-scroll-target="#bwa">BWA</a></li>
  </ul></li>
  <li><a href="#marking-duplicates" id="toc-marking-duplicates" class="nav-link" data-scroll-target="#marking-duplicates">Marking Duplicates</a>
  <ul class="collapse">
  <li><a href="#sambamba" id="toc-sambamba" class="nav-link" data-scroll-target="#sambamba">Sambamba</a></li>
  </ul></li>
  <li><a href="#long-read-mapping" id="toc-long-read-mapping" class="nav-link" data-scroll-target="#long-read-mapping">Long-read mapping</a>
  <ul class="collapse">
  <li><a href="#task-5-map-reads-to-the-reference-genome" id="toc-task-5-map-reads-to-the-reference-genome" class="nav-link" data-scroll-target="#task-5-map-reads-to-the-reference-genome">Task 5: Map reads to the reference genome</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#variant-calling" id="toc-variant-calling" class="nav-link" data-scroll-target="#variant-calling">Variant calling</a>
  <ul class="collapse">
  <li><a href="#variant-calling-in-short-reads---bcftools" id="toc-variant-calling-in-short-reads---bcftools" class="nav-link" data-scroll-target="#variant-calling-in-short-reads---bcftools">Variant calling in short-reads - BCFtools</a>
  <ul class="collapse">
  <li><a href="#task-6-complete-the-variant-calling-command" id="toc-task-6-complete-the-variant-calling-command" class="nav-link" data-scroll-target="#task-6-complete-the-variant-calling-command">Task 6: Complete the Variant Calling command:**</a></li>
  </ul></li>
  <li><a href="#long-read-variant-calling" id="toc-long-read-variant-calling" class="nav-link" data-scroll-target="#long-read-variant-calling">Long-read variant calling</a>
  <ul class="collapse">
  <li><a href="#task-7-call-snps-against-the-human-reference-genome" id="toc-task-7-call-snps-against-the-human-reference-genome" class="nav-link" data-scroll-target="#task-7-call-snps-against-the-human-reference-genome">Task 7: Call SNPs against the human reference genome**</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#benchmarking" id="toc-benchmarking" class="nav-link" data-scroll-target="#benchmarking">Benchmarking</a></li>
  <li><a href="#vcf-comparison" id="toc-vcf-comparison" class="nav-link" data-scroll-target="#vcf-comparison">VCF comparison</a>
  <ul class="collapse">
  <li><a href="#task-8-benchmarking-metrics-from-vcf-file" id="toc-task-8-benchmarking-metrics-from-vcf-file" class="nav-link" data-scroll-target="#task-8-benchmarking-metrics-from-vcf-file">Task 8: Benchmarking metrics from VCF file</a></li>
  </ul></li>
  <li><a href="#genome-wide-assessment-using-genomic-windows" id="toc-genome-wide-assessment-using-genomic-windows" class="nav-link" data-scroll-target="#genome-wide-assessment-using-genomic-windows">Genome-wide assessment using genomic windows</a>
  <ul class="collapse">
  <li><a href="#task-9-benchmarking-of-different-sequencing-technologies-for-snp-calling." id="toc-task-9-benchmarking-of-different-sequencing-technologies-for-snp-calling." class="nav-link" data-scroll-target="#task-9-benchmarking-of-different-sequencing-technologies-for-snp-calling.">Task 9: Benchmarking of different sequencing technologies for SNP calling.</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="1_sequencing_techs.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../modules/1_sequencing_techs/1_sequencing_techs.html">Module 1: Sequencing technologies</a></li><li class="breadcrumb-item"><a href="../../modules/1_sequencing_techs/1_sequencing_techs.html">Assignment 1: Next Generation Sequencing Technologies</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Assignment 1: Next Generation Sequencing Technologies</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Arturo Torres Ortiz </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 13, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- > Due date: February 12th 2026 -->
<p>DNA sequencing can be broadly defined as the determination of the identity and order of nucleic acid residues in biological samples. Bioinformatic analysis and sequencing results are greatly affected by the choice of sequencing technlogy. Sequencing technologies can be broadly categorized in three groups:</p>
<ol type="1">
<li><strong>First-Generation Sequencing</strong>
<ul>
<li>First-generation sequencing methods, most notably Sanger sequencing, relied on using radio- or fluorescently-labelled dNTPs or oligonucleotides before electrophoretic analysis.</li>
</ul></li>
<li><strong>Second-Generation Sequencing</strong>
<ul>
<li>Second-generation sequencing is characterized by its high throughput due to the parallelisation of a large number of reactions, sequencing thousands to millions of DNA fragments. Second-Generation sequencing includes the current sequencing leader, Illumina.</li>
</ul></li>
<li><strong>Third-Generation Sequencing</strong>
<ul>
<li>Third-generation sequencing technologies include those capable of sequencing single molecules, so they don’t require DNA amplification. The two most common third-generation sequencing technologies include PacBio (Pacific Biosciences) and ONT (Oxford Nanopore).</li>
</ul></li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Generation</th>
<th style="text-align: left;">Sequencing Technology</th>
<th style="text-align: left;">Year</th>
<th style="text-align: left;">Company</th>
<th style="text-align: left;">Avg Read Length</th>
<th style="text-align: left;">Cost per Gigabase</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>First Generation</strong></td>
<td style="text-align: left;">Sanger Sequencing</td>
<td style="text-align: left;">1977</td>
<td style="text-align: left;">Frederick Sanger</td>
<td style="text-align: left;">~800 bp</td>
<td style="text-align: left;">Very High (&gt;$1000)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Second Generation</strong></td>
<td style="text-align: left;">454 Sequencing</td>
<td style="text-align: left;">2005</td>
<td style="text-align: left;">Roche</td>
<td style="text-align: left;">~400 bp</td>
<td style="text-align: left;">High ($100 - $500)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Illumina (Solexa)</td>
<td style="text-align: left;">2006</td>
<td style="text-align: left;">Illumina</td>
<td style="text-align: left;">~150-300 bp</td>
<td style="text-align: left;">Low ($1 - $10)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">Ion Torrent</td>
<td style="text-align: left;">2010</td>
<td style="text-align: left;">Thermo Fisher</td>
<td style="text-align: left;">~200 bp</td>
<td style="text-align: left;">Medium ($10 - $50)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Third Generation</strong></td>
<td style="text-align: left;">PacBio SMRT</td>
<td style="text-align: left;">2009</td>
<td style="text-align: left;">Pacific Biosciences</td>
<td style="text-align: left;">10,000+ bp</td>
<td style="text-align: left;">High ($50 - $200)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">Oxford Nanopore</td>
<td style="text-align: left;">2014</td>
<td style="text-align: left;">ONT</td>
<td style="text-align: left;">10,000+ bp</td>
<td style="text-align: left;">Medium-High ($10-$100)</td>
</tr>
</tbody>
</table>
<p>We will use a human genome standard (HG002) that has been extremely well-characterized as our gold standard. The HG002 genome assembly is part of an effort hosted by NIST that includes The Telomere-to-Telomere Consortium, the Human Pangenome Reference Consortium and the Genome in a Bottle Consortium, to sequence, assemble and polish the HG002 (also known as GM24385 and huAA53E0) cell line, creating a human “genome benchmark” for the HG002 reference material that covers all bases of the diploid genome and is perfectly accurate. Hence, their own “Q100” project nickname, which refers to a Phred quality score of 1 error per 10 billion bases.</p>
<p>Some reference papers regarding this dataset:</p>
<ul>
<li>Zook, J., Catoe, D., McDaniel, J. et al.&nbsp;Extensive sequencing of seven human genomes to characterize benchmark reference materials. Sci Data 3, 160025 (2016). https://doi.org/10.1038/sdata.2016.25</li>
<li>Zook, J.M., McDaniel, J., Olson, N.D. et al.&nbsp;An open resource for accurately benchmarking small variant and reference calls. Nat Biotechnol 37, 561–566 (2019). https://doi.org/10.1038/s41587-019-0074-6</li>
<li>Zook, J.M., Hansen, N.F., Olson, N.D. et al.&nbsp;A robust benchmark for detection of germline large deletions and insertions. Nat Biotechnol 38, 1347–1355 (2020). https://doi.org/10.1038/s41587-020-0538-8</li>
<li>Liao, WW., Asri, M., Ebler, J. et al.&nbsp;A draft human pangenome reference. Nature 617, 312–324 (2023). https://doi.org/10.1038/s41586-023-05896-x</li>
<li>Rhie, A., Nurk, S., Cechova, M. et al.&nbsp;The complete sequence of a human Y chromosome. Nature 621, 344–354 (2023). https://doi.org/10.1038/s41586-023-06457-y</li>
</ul>
<p>We will compare the characteristics and SNP calls for three sequencing technologies: Illumina, PacBio HiFi, and Nanopore.</p>
<section id="learning-objectives" class="level1">
<h1>Learning objectives</h1>
<p>At the end of this week’s assignment you will be able to:</p>
<ol type="1">
<li>Understand the principles behind the different sequencing technologies</li>
<li>Library preparation methods and their effect on the data</li>
<li>Understand the notion of a resequencing experiment and a reference genome</li>
<li>Perform quality check and control (QC) on Illumina short-read data</li>
<li>Perform quality check and control on long-read sequencing data</li>
<li>Align short-reads to a reference genome</li>
<li>Align long-reads to a reference genome</li>
<li>Understand the SAM and BAM format</li>
<li>Call SNPs against a reference genome in short-read data</li>
<li>Call SNPs against a reference genome in long-read sequencing data</li>
<li>Understand the VCF format</li>
<li>Analyze differences between sequencing technologies</li>
<li>Use common benchmarking metrics</li>
</ol>
</section>
<section id="input-and-outputs" class="level1">
<h1>Input and outputs</h1>
<p>The input for this assignment are the fastq files generated by Illumina, PacBio HiFi and ONT of the standard human genome HG002. Each student will be given a chromosome to work with.</p>
<blockquote class="blockquote">
<p>Illumina files:</p>
<p><code>/project2/msalomon_1816/trgn_515/1_seq_techs/illumina/fastq</code></p>
</blockquote>
<blockquote class="blockquote">
<p>PacBio files:</p>
<p><code>/project2/msalomon_1816/trgn_515/1_seq_techs/pacbio/fastq</code></p>
</blockquote>
<blockquote class="blockquote">
<p>Nanopore files:</p>
<p><code>/project2/msalomon_1816/trgn_515/1_seq_techs/ont/fastq</code></p>
</blockquote>
<blockquote class="blockquote">
<p>Benchmarking file:</p>
<p><code>/project2/msalomon_1816/trgn_515/1_seq_techs/benchmark/HG002_GRCh38_1_22_v4.2.1_benchmark.vcf.gz</code></p>
</blockquote>
<blockquote class="blockquote">
<p>Human Reference Genome GRCh38</p>
<p><code>/project2/biodb/genomes/Homo_sapiens/NCBI/GRCh38/Sequence/BWAIndex/genome.fa</code></p>
<p><code>/project2/biodb/genomes/Homo_sapiens/NCBI/GRCh38/Sequence/WholeGenomeFasta/genome.fa</code></p>
</blockquote>
<blockquote class="blockquote">
<p>Original data can be found at: https://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/AshkenazimTrio/HG002_NA24385_son/ For the benchmarking: https://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/release/AshkenazimTrio/HG002_NA24385_son/NISTv4.2.1/GRCh38/ <!-- https://s3-us-west-2.amazonaws.com/human-pangenomics/index.html?prefix=NHGRI_UCSC_panel/HG002/ --></p>
</blockquote>
<!-- for n in {1..5}; do ( samtools view -hb HG002_PacBio-HiFi-Revio_20231031_48x_GRCh38-GIABv3.bam chr$n | samtools collate -Ou - | samtools fastq | gzip > ../fastq/chr$n.fastq.gz ) & done -->
<!-- https://github.com/marbl/HG002 -->
<!-- https://github.com/human-pangenomics/HG002_Data_Freeze_v1.0-->
<!-- https://github.com/marbl/CHM13/tree/master -->
<!-- https://docs.google.com/spreadsheets/d/1eUXfyTqWVy9O3bYYyZdiEoWhnztUJXIf7u8X3UE-ryg/edit?gid=1481031002#gid=1481031002 -->
<!-- For Nanopore, the raw data is: UCSC_Ultralong_OxfordNanopore_Promethion -->
<!-- For PacBio, the raw data is: PacBio_HiFi-Revio_20231031 -->
<!-- For Illumina, the raw data is: HG002Run01-11419412 -->
<blockquote class="blockquote">
<p>The final output will be a list of SNPs and statistics for each sequencing technology.</p>
</blockquote>
</section>
<section id="required-software" class="level1">
<h1>Required software</h1>
<p>In order to complete the assignment, the following tools need to be installed:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">mamba</span> install bioconda::filtlong</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">mamba</span> install bioconda::minimap2</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">mamba</span> install bioconda::seqtk</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">mamba</span> install bioconda::seqkit</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load bwa</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load htslib</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load bcftools</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load samtools</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load fastqc</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load gcc/13.3.0</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load bedtools2/2.31.1</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load gatk/4.5.0.0</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The easiest way to install all these dependencies is to use the conda environment I provide here:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> activate /project2/msalomon_1816/trgn_515/conda_env/1_seq_techs</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="manipulating-fastq-files" class="level1">
<h1>Manipulating Fastq files</h1>
<p>Fastq files are simply text files with a specific and constant format, so you can always parse them using <code>bash</code> or any scripting language. For instance, since you know the read sequence is on the 2nd line and the quality sequence is on the 4th line, to get read length for every read you can simply do:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">awk</span> <span class="st">'NR==4 {print length}'</span> <span class="op">&lt;</span>fastq_file.fq<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>However, for reproducibility and consistency (and to save us time), there are already well-established software to parse and manipulate fastq files efficiently. Some widely used tools are: 1. <code>seqtk</code> - https://github.com/lh3/seqtk 2. <code>seqkit</code> - https://bioinf.shenwei.me/seqkit/ 3. <code>bioawk</code> - https://github.com/lh3/bioawk</p>
<p>All of these come with a pletora of algorithms to parse fastq files, change between formats, merge, split, etc. <code>seqkit</code> is more complex and it has more options for parallel computing, but <code>seqtk</code> is more lightweight and usually faster. I suggest you take some time to check the tutorial for each of them in their respective github pages.</p>
<section id="task-1-compare-raw-read-statistics-between-sequencing-technologies" class="level3">
<h3 class="anchored" data-anchor-id="task-1-compare-raw-read-statistics-between-sequencing-technologies">Task 1: Compare raw read statistics between sequencing technologies</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For this first task, let’s extract some basic metrics from the raw fastq files and compare between sequencing technologies. To be efficient, let’s take a random sample of 200,000 reads per sequencing technology.</p>
<p>The metrics we will report are:</p>
<ul>
<li>Read length</li>
<li>Average Base quality per read</li>
<li>GC content per read</li>
</ul>
<p>One way to do it using one of the previously shown software is:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">seqtk</span> sample <span class="at">-s</span> 100 <span class="co"># random seed</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>fastq_file<span class="op">&gt;</span> <span class="co"># Input fastq file</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>n_reads<span class="op">&gt;</span> <span class="co"># Number of reads to downselect</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">|</span> <span class="ex">seqkit</span> fx2tab <span class="co"># Main seqkit function to get read stats</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ex">-q</span> <span class="co"># Get average read quality</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="ex">-l</span> <span class="co"># Get read length</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ex">-g</span> <span class="co"># Get GC content</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ex">-n</span> <span class="co"># Only print read name</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ex">-</span> <span class="op">&gt;</span> <span class="op">&lt;</span>output_file.txt<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol type="1">
<li>Plot a histogram of each of the three metrics. Plot all illumina (forward reads only), ont and pacbio together. <strong>(10pts)</strong></li>
<li>Describe briefly the differences in read length, base quality and GC content per sequencing platform <strong>(10pts)</strong></li>
</ol>
</div>
</div>
</section>
</section>
<section id="oxford-nanopore-output-files" class="level1">
<h1>Oxford Nanopore output files</h1>
<p>All sequencing technologies reviewed during this assignment output reads either in Fastq or BAM format (unaligned BAM or aligned if a reference genome is provided). Remember that both Fastq and BAM format are interchangable.</p>
<p>However, ONT also output a special type of file. The output of Nanopore sequencing is in the Pod5 file format. This was previously known as Fast5 (and will probably be something different soon!). Pod5 is a lot more efficient and lightweight. Pod5 files are binaries files that contain all the data that nanopore sequencing outputs, which includes raw sequence data (picoampere measurements taken at the nanopores thousands of times per second) and sample metadata.</p>
<p>The process of transforming the raw signal data into basepairs is known as basecalling, and it’s one of the most important elements in the Oxford Nanopore Technology. Usually this is done in real-time during sequencing, but sometimes you may want to do it afterwards. Even though the real-time output will be demultiplex, when you basecall on your own you will have to demultiplex it again through the <code>demux</code> command. Everything can be done using <code>dorado</code> (this software is likely to change, as it always happens with Nanopore).You can do so with the following command:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dorado</span> basecaller <span class="co"># Basecalling algorithm</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-r</span> <span class="co"># Recursively scan through folders and files. This may not be necessary</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ex">--kit-name</span> <span class="co"># ONT Nanopore kit (eg: SQK-NBD114-24 for native barcoding, SQK-RPB114-24 for rapid barcoding or EXP-PBC001 for PCR expansion kit)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>model<span class="op">&gt;</span> <span class="co"># Model for basecalling: fast, hac, sup</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input_directory<span class="op">&gt;</span> <span class="co"># Input directory with Pod5 files</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">|</span> <span class="ex">dorado</span> demux <span class="co"># Demultiplexing algorithm</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ex">--threads</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Number of threads</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ex">--no-classify</span> <span class="co"># Skip barcode classification, as this is done during basecalling</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ex">--emit-fastq</span> <span class="co"># Output fastq. Default is BAM</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="ex">--barcode-both-ends</span> <span class="co"># Optional: Require both ends of a read to be barcoded for more precise but less sensitive barcoding</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="ex">--output-dir</span> <span class="op">&lt;</span>out_dir<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For better quality, ONT has recently allowed users to perform duplex basecalling. By reading both the forward and reverse strands through the pore, duplex basecalling can increase the confidence in the basecalls, thus increasing the base quality. To perform duplex basecalling and demultiplexing, you can run the following code:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># run your dataset through simplex basecalling with barcoding enabled</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dorado</span> basecaller <span class="op">&lt;</span>model<span class="op">&gt;</span> <span class="op">&lt;</span>pod5<span class="op">&gt;</span> --kit-name <span class="op">&lt;</span>barcode-kit<span class="op">&gt;</span> <span class="kw">|</span> <span class="ex">dorado</span> demux <span class="at">--no-classify</span> <span class="at">--output-dir</span> <span class="op">&lt;</span>out_dir<span class="op">&gt;</span> <span class="co"># classify and split the dataset</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># then fetch the read ids per barcode from the corresponding .bam and put it in a read.txt file</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># then run</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ex">dorado</span> duplex <span class="op">&lt;</span>model<span class="op">&gt;</span> <span class="op">&lt;</span>pod5<span class="op">&gt;</span> --read-ids reads.txt</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># and this will run duplex basecalling only with the read ids from that barcode</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="quality-check" class="level1">
<h1>Quality Check</h1>
<p>The first step in most bioinformatic analysis will be to visualize the quality of the raw reads.</p>
<p>Most quality control depends on base qualities. Sequencers attempt to read the “sequence” of DNA letters. For each base they read, they assign a quality score that serves as a measure of confidence in that base, called a Phred quality score. These typically range from 0-40, with higher values meaning greater confidence in the base that was called. This is a logarithmic scale, such that, if a base has an associated quality score of 20, there is a 1 in 100 chance that it is incorrect. If it has a score of 30, there is a 1 in 1,000 chance it is incorrect.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Phred Quality Score</th>
<th style="text-align: center;">Probability of incorrect basecall</th>
<th style="text-align: center;">Basecall accuracy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">10</td>
<td style="text-align: center;">1 in 10</td>
<td style="text-align: center;">90%</td>
</tr>
<tr class="even">
<td style="text-align: center;">20</td>
<td style="text-align: center;">1 in 100</td>
<td style="text-align: center;">99%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">30</td>
<td style="text-align: center;">1 in 1000</td>
<td style="text-align: center;">99.9%</td>
</tr>
<tr class="even">
<td style="text-align: center;">40</td>
<td style="text-align: center;">1 in 10,000</td>
<td style="text-align: center;">99.99%</td>
</tr>
</tbody>
</table>
<section id="quality-check-for-short-reads---fastqc" class="level2">
<h2 class="anchored" data-anchor-id="quality-check-for-short-reads---fastqc">Quality check for short-reads - FastQC</h2>
<p>The most widely used tool for visually evaluating fastq data is FastQC. If FastQC is ran without arguments, it will open an interactive GUI version of the software. But in most cases, we will run it in the command line.</p>
<p>A basic way to call FastQC will the following command:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">fastqc</span> <span class="co"># The main command call</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">--extract</span> <span class="co"># Extract files from output</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-o</span> <span class="op">&lt;</span>output_dir<span class="op">&gt;</span> <span class="co"># Directory for output files</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ex">-d</span> <span class="op">&lt;</span>temporary_dir<span class="op">&gt;</span> <span class="co"># Directory for temporary files</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input.fq<span class="op">&gt;</span> <span class="co"># Input fasta file</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This code can be embedded within a python script or a cluster slurm batch job. An easy way to run it within bash in a batch script would be:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --account=msalomon_1385</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --partition=main</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --ntasks=1</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --cpus-per-task=1</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --mem=5G</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --time=1:00:00</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --job-name=fastqc</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --output=/scratch1/USER/temp/fastqc_%j.%a.out</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --error=/scratch1/USER/temp/fastqc_%j.%a.err</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Put the input and output directories into variables for conciseness</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="va">in_dir</span><span class="op">=</span>/project/msalomon_1385/TRGN_515/1_exp_evolution/data/m_tuberculosis/fastq</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="va">out_dir</span><span class="op">=</span>/scratch1/USER/1_exp_evolution/fastq_qc</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Then we loop over all files within the directory</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> in_fa <span class="kw">in</span> <span class="va">$in_dir</span>/<span class="pp">*</span>.fastq.gz<span class="kw">;</span> <span class="co"># Initiate loop</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="va">sample</span><span class="op">=</span><span class="va">$(</span><span class="fu">basename</span> <span class="va">$in_fa</span> .fastq.gz<span class="va">)</span> <span class="co"># Set up a sample variable for the output.</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="ex">fastqc</span> <span class="at">-o</span> <span class="va">$out_dir</span>/<span class="va">$sample</span> <span class="at">--extract</span> <span class="at">--dir</span> <span class="va">$out_dir</span> <span class="va">$in_fa</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span> <span class="co"># Finilize loop</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>But remember, this is just one way to run it!</p>
</section>
<section id="quality-check-for-long-reads" class="level2">
<h2 class="anchored" data-anchor-id="quality-check-for-long-reads">Quality check for long-reads</h2>
<p>You can visualize the quality of your long reads using FastQC as you would with your short-reads. However, there’s also specific software built for long-reads. A widely used software is <code>NanoPlot</code>. Another option is <code>LongQC</code>.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you use FastQC on very long reads, it may run out of memory. By default, FastQC allocates a very small amount of memory (512MB), which makes it run out of memory with very long reads. The way to fix this issue is to allocate more memory using the <code>--memory</code> flag. So if you use FastQC, allocate 5Gb, which should be more than enough. You can do this with the command:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">fastqc</span> <span class="at">--extract</span> <span class="at">-o</span> <span class="op">&lt;</span>output_dir<span class="op">&gt;</span> --d <span class="op">&lt;</span>temporary_dir<span class="op">&gt;</span> --memory 5000 <span class="op">&lt;</span>input.fq<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</div>
<p>NanoPlot is equally easy to run. It will give similar output to FastQC, but more centered on read length and base quality, which is often the obsession with Nanopore long reads.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">NanoPlot</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ex">--fastq</span> <span class="op">&lt;</span>input.fq<span class="op">&gt;</span> <span class="co"># Input in fastq file</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-o</span> <span class="op">&lt;</span>output_dir<span class="op">&gt;</span> <span class="co"># Output directory</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ex">--loglength</span> <span class="co"># Set up for log read length in the plots</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="task-2-run-fastqc-on-illumina-reads" class="level3">
<h3 class="anchored" data-anchor-id="task-2-run-fastqc-on-illumina-reads">Task 2: Run FastQC on Illumina reads</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Run FastqQC on the Illumina reads and answer the questions. Focus only on the following figures:</p>
<ul>
<li>Per base sequence quality</li>
<li>Per sequence quality scores</li>
<li>Per base sequence content</li>
<li>Per sequence GC content</li>
<li>Per base N content</li>
<li>Sequence Length Distribution</li>
<li>Overrepresented sequences</li>
<li>Adapter Content</li>
</ul>
<p>Answer the following questions for each plot:</p>
<ol type="1">
<li>What is the plot representing? <strong>(10pts)</strong></li>
<li>What quality issue (if any) is the plot showing? <strong>(10pts)</strong></li>
<li>How would you solve the issue (if any) represented in the plot? <strong>(10pts)</strong></li>
</ol>
<p>Answer the questions for the forward reads only.</p>
</div>
</div>
</section>
</section>
</section>
<section id="quality-control-qc" class="level1">
<h1>Quality Control (QC)</h1>
<p>Now that we have visualize the raw fastq files, we may want to filter some reads and remove potential errors from the reads in order to remove poor quality data. This is called quality control. Most basic quality control tools will perform two or three tasks:</p>
<ul>
<li>Remove low quality reads</li>
<li>Trim low quality bases at the beginning and end of reads</li>
<li>Trim adaptors</li>
</ul>
<p>These steps should be sufficient for QC. Data that requires more aggressive steps may be too unreliable to continue analysis.</p>
<section id="qc-for-short-reads---trimmomatic" class="level2">
<h2 class="anchored" data-anchor-id="qc-for-short-reads---trimmomatic">QC for short-reads - Trimmomatic</h2>
<p>Multiple tools are commonly used to perform QC on short-reads: 1. <code>Trimmomatic</code> - https://github.com/usadellab/Trimmomatic 2. <code>fastp</code> - https://github.com/OpenGene/fastp 3. <code>Trim Galore!</code> - https://github.com/FelixKrueger/TrimGalore</p>
<p>We will use <code>Trimmomatic</code> for this. To remove adapters, you need to provide a file with the adapters for the Illumina machine the reads come from. If you installed Trimmomatic through a conda distribution, that should be within: <code>anaconda3/share/trimmomatic/adapters/</code>. You can also find it at their github page.</p>
<p>To run trimmomatic:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">trimmomatic</span> PE <span class="co"># Main trimmomatic function for paired-ends reads</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input_1.fastq.gz<span class="op">&gt;</span> <span class="co"># Forward reads</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input_2.fastq.gz<span class="op">&gt;</span> <span class="co"># Reverse reads</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output_1.fastq.gz<span class="op">&gt;</span> <span class="co"># Output forward reads</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output_unclassified_1.fastq.gz<span class="op">&gt;</span> <span class="co"># Output unclassified reads from forward file</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output_2.fastq.gz<span class="op">&gt;</span> <span class="co"># Output reverse reads</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output_unclassified_2.fastq.gz<span class="op">&gt;</span> <span class="co"># Output unclassified reads from reverse file</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="ex">SLIDINGWINDOW:</span><span class="op">&lt;</span>window_size<span class="op">&gt;</span>:<span class="op">&lt;</span>quality<span class="op">&gt;</span> <span class="co"># Sliding window for quality trimming.</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="ex">LEADING:</span><span class="op">&lt;</span>quality<span class="op">&gt;</span> <span class="co"># Remove leading bases under quality</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ex">TRAILING:</span><span class="op">&lt;</span>quality<span class="op">&gt;</span> <span class="co"># Remove trailing bases under quality</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="ex">AVGQUAL:</span><span class="op">&lt;</span>quality<span class="op">&gt;</span> <span class="co"># Average quality to remove a read</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ex">MINLEN:</span><span class="op">&lt;</span>length<span class="op">&gt;</span> <span class="co"># Minimum length to remove a read</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="ex">ILLUMINACLIP:</span><span class="op">&lt;</span>/path/to/adapter_file.fa<span class="op">&gt;</span>:<span class="op">&lt;</span>seed_mismatches<span class="op">&gt;</span>:palindrome_clip_threshold<span class="op">&gt;</span>:<span class="op">&lt;</span>simple_clip_threshold<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For the <code>SLIDINGWINDOW</code> argument, a window of <code>window_size</code> size moves along the read. If the average quality of the window falls below <code>quality</code>, the remaining of the read is clipped. This prevents reads to be removed just because of a few bad bases. This argument assumes the quality will only get worse at the end of the read.</p>
<p>The <code>LEADING</code> and <code>TRAILING</code> arguments will start at the begonning and end of the read and keep removing bases as long as their quality is below <code>quality</code>.</p>
<p>For <code>ILLUMINACLIP</code>, we need to provide the file for the adapters. This depends on the Illumina machine. The <code>seed_mismatches</code> argument specifies the maximum number of base mismatches allowed within a short initial sequence from the read (“seed”, 16bp) used to identify potential adapter matches, allowing for a small degree of mismatch when searching for adapters to clip. Trimmomatic uses two strategies to find adapters: the sample mode, and the palindromic mode. <code>simple_clip_threshold</code> is the minimum score threshold for the adapter to align to the read for clipping to take place in the simple mode. Suggested values are 7-15. <code>palindrome_clip_threshold</code> specifies how accurate the match between the two ‘adapter ligated’ reads must be for paired-end palindrome read alignment. Suggested values are around 30. For more information, these two strategies are extensively explained in the Trimmomatic publication.</p>
<p>For our dataset, we can run Trimmomatic within bash as follows:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="va">in_dir</span><span class="op">=</span>/project/msalomon_1385/TRGN_515/1_seq_techs/illumina</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="va">out_dir</span><span class="op">=</span>/scratch1/USER/1_exp_evolution/fastq_pass</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="va">adapters</span><span class="op">=</span>/path/to/conda/share/trimmomatic/adapters/TruSeq3-PE.fa</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Unlike FastQC, we need to run both forward and reverse reads together</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> file <span class="kw">in</span> <span class="va">$in_dir</span>/<span class="pp">*</span>_1.fastq.gz<span class="kw">;</span> <span class="co"># Initiate loop with forward reads only</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">sample</span><span class="op">=</span><span class="va">$(</span><span class="fu">basename</span> <span class="va">$in_fa</span> _1.fastq.gz<span class="va">)</span> <span class="co"># Set up a sample variable for input and output.</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">fwd</span><span class="op">=</span><span class="va">$in_dir</span>/<span class="va">${sample}</span>_1.fastq.gz <span class="co"># Forward read</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">rev</span><span class="op">=</span><span class="va">$in_dir</span>/<span class="va">${sample}</span>_2.fastq.gz <span class="co"># Reverse read</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="ex">trimmomatic</span> PE <span class="va">$fwd</span> <span class="va">$rev</span> <span class="va">$out_dir</span>/<span class="va">${sample}</span>_1.fastq.gz /dev/null <span class="va">$out_dir</span>/<span class="va">${sample}</span>_2.fastq.gz /dev/null SLIDINGWINDOW:4:5 LEADING:5 TRAILING:5 AVGQUAL:5 MINLEN:35 ILLUMINACLIP:<span class="va">$adapters</span>:2:30:10</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note we send unclassified reads to /dev/null</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span> <span class="co"># Finilize loop</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="task-3-run-fastqc-after-running-trimmomatic" class="level3">
<h3 class="anchored" data-anchor-id="task-3-run-fastqc-after-running-trimmomatic">Task 3: Run FastQC after running Trimmomatic</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Compare the following FastqQC plots before and after:</p>
<ul>
<li>Per base sequence quality</li>
<li>Per sequence quality scores</li>
<li>Per base sequence content</li>
<li>Per sequence GC content</li>
<li>Per base N content</li>
<li>Sequence Length Distribution</li>
<li>Overrepresented sequences</li>
<li>Adapter Content</li>
</ul>
<p>Answer the following questions for each plot:</p>
<ol type="1">
<li>What has changed after running trimmomatic? <strong>(10pts)</strong></li>
<li>Why did the change happen? <strong>(10pts)</strong></li>
</ol>
</div>
</div>
</section>
</section>
</section>
<section id="qc-of-long-reads" class="level1">
<h1>QC of long reads</h1>
<p>The QC for long reads is very similar to that of short-reads, the only difference is the type of adaptors expected and the distribution of quality scores. This are some example of softwares for long-read QC:</p>
<p><code>filtlong</code>. An interesting feature of filtlong is that you can keep the best x% reads, rather than hard filtering. For instance:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">filtlong</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ex">--min_length</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Minimum read length</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ex">--min_mean_q</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Minimum mean base quality</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ex">--keep_percent</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Keep the best n% of reads</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input_reads<span class="op">&gt;</span> <span class="kw">|</span> </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="fu">gzip</span> <span class="op">&gt;</span> <span class="op">&lt;</span>output_reads<span class="op">&gt;</span>.gz</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="task-4-long-read-qc" class="level3">
<h3 class="anchored" data-anchor-id="task-4-long-read-qc">Task 4: Long read QC</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Filter raw reads for the nanopore and pacbio datasets. Use <code>filtlong</code>. Keep the best 95% of reads.</p>
<p>Choose minimum read length and base quality based on the data from the first time you ran NanoPlot.</p>
<ol type="1">
<li>What changes in the statistics and plots can you observe after running filtlong? <strong>(10pts)</strong></li>
</ol>
</div>
</div>
</section>
</section>
<section id="read-mapping-to-a-reference-genome" class="level1">
<h1>Read mapping to a reference genome</h1>
<section id="short-read-mapping" class="level2">
<h2 class="anchored" data-anchor-id="short-read-mapping">Short-read mapping</h2>
<section id="bwa" class="level3">
<h3 class="anchored" data-anchor-id="bwa">BWA</h3>
<p>To run any read mapping software, we first need a reference genome. We will use the Human Reference Genome version GRCh38. You can find the CARC location for this file at the beginning of this document.</p>
<p>Most modern mappers require building an index to easily parse the reference genome during mapping. In fact, some of the biggest speed and memory improvements over early mappers was thanks to improved indexing methods. If they don’t require an index file, it’s because they index the reference genome on the fly. BWA, for instance, is based on the Burrows-wheeler Transform for powerful indexing to quickly locate where a read might align within the reference genome. The indexing for BWA can be done with the following command:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bwa</span> index <span class="va">$ref_genome</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>That will create multiple files with the same name as your reference genome, but ending in different extensions. Those are the indexes. Keep those files with the same and location as your reference genome. If a software requires those indexes, you just need to show the location of the reference genome, and it will assume the name and location of all the indexes.</p>
<p>On CARC there’s already a folder with the indexed GRCh38 reference genome, so we don’t need to do this step.</p>
<p>The basic use of BWA requires only the indexed reference genome and the files for the reads (or single file if not paired-end). To run BWA, do:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bwa</span> mem <span class="co"># Main call for the mem algorithm within BWA</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>reference_genome<span class="op">&gt;</span> <span class="co"># Reference genome</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>fastq1<span class="op">&gt;</span> <span class="co"># Forward reads</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>fastq2<span class="op">&gt;</span> <span class="co"># Reverse reads</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>An important part of the BAM file is the Read Group, especially for Illumina reads. Read groups provide technical information about flowcell, lane and multiplexing of illumina reads. This is important for finding library and sequencing issues, as well as for removing duplicates (next section!). Read Groups are added within the header with the tag <code>RG</code>. To find the flowcell and lane information you can use the headers of a fastq file. For modern fastq files:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="va">flowcell</span><span class="op">=</span><span class="va">$(</span><span class="fu">zcat</span> <span class="op">&lt;</span>file.fq.gz<span class="op">&gt;</span> <span class="kw">|</span> <span class="fu">head</span> <span class="at">-n1</span> <span class="kw">|</span> <span class="fu">cut</span> <span class="at">-d</span><span class="st">':'</span> <span class="at">-f3</span><span class="va">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="va">lane</span><span class="op">=</span><span class="va">$(</span><span class="fu">zcat</span> <span class="op">&lt;</span>file.fq.gz<span class="op">&gt;</span> <span class="kw">|</span> <span class="fu">head</span> <span class="at">-n1</span> <span class="kw">|</span> <span class="fu">cut</span> <span class="at">-d</span><span class="st">':'</span> <span class="at">-f4</span><span class="va">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Two common flags to add are the Read Group ID abd the Platform unit. You can define them as:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="va">rg_id</span><span class="op">=</span><span class="va">$flowcell</span>.<span class="va">$lane</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="va">pu</span><span class="op">=</span><span class="va">$flowcell</span>.<span class="va">$lane</span>.<span class="va">$sample</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Where <code>$sample</code> is your sample name. To add read groups on <code>bwa mem</code>, use the <code>-R</code> flag.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bwa</span> mem <span class="at">-R</span> <span class="st">"@RG\tID:</span><span class="va">$rg_id</span><span class="st">\tPU:</span><span class="va">$pu</span><span class="st">\tPL:</span><span class="va">$pl</span><span class="st">\tSM:</span><span class="va">$sample</span><span class="st">"</span> </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The read group ID and platform information allows us to find library and sequencing bias. The sample name makes the BAM and VCF file a lot more concise later on, as the sample name is extracted from there.</p>
<p>Fastq files generated with older machines have different headers. You can find more information about the Fastq headers here (https://en.wikipedia.org/wiki/FASTQ_format) and about Read groups in the GATK website (https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups).</p>
<p><strong>NOTE:</strong> Some fastq files may have more than one flowcell and lane for all the reads if the sample was sequenced in multiple flowcell lanes. In that case, if you detect bias in the Per Tile plot in FastQC, you may have to separate the reads by flowcell and lane before mapping.</p>
<p>The output of bwa is sometimes unsorted. To ensure we have a coordinate sorted bam file (sorted by starting position), do the following:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> sort <span class="co"># Main call</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-@</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Number of threads</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-T</span> <span class="op">&lt;</span>path<span class="op">&gt;</span> <span class="co"># Temporary directory</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ex">-O</span> bam <span class="co"># Output in bam format</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ex">-o</span> <span class="op">&lt;</span>path<span class="op">&gt;</span> <span class="co"># Output directory</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="ex">intput_bam</span> <span class="co"># Input bam file</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><code>samtools sort</code> allows for other types of sorting, such as read name sorting or tag-based sorting, but coordinate sorting is by far the most common and expected by downstream bioinformatic processes.</p>
<p>Many tools will require to index the output bam file for efficiency. This can be done with:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> index bam_file<span class="kw">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We can combine everything into one command using bash pipes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bwa</span> mem <span class="op">&lt;</span>reference_genome<span class="op">&gt;</span> <span class="op">&lt;</span>fastq1_path<span class="op">&gt;</span> <span class="op">&lt;</span>fastq2_path<span class="op">&gt;</span> <span class="kw">|</span> <span class="ex">samtools</span> view <span class="at">-bS</span> <span class="at">-</span> <span class="kw">|</span> <span class="ex">samtools</span> sort <span class="at">-@</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> -T <span class="op">&lt;</span>path<span class="op">&gt;</span> -O bam <span class="at">-o</span> <span class="op">&lt;</span>out_bam_path<span class="op">&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> index <span class="op">&lt;</span>out_bam_path<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="marking-duplicates" class="level2">
<h2 class="anchored" data-anchor-id="marking-duplicates">Marking Duplicates</h2>
<p>The term “duplicates” usually refers to identical sequences that appear more than once in the data. Duplicated sequences can be genuine, meaning that they are created due to real duplicated fragments in the genome. However, these duplicates can also occur due to library prep and sequencing artifacts. High rate of artificial duplicates can impact variant detection, as a variant may seem supported by many independent reads when in reality it’s just an error artificially duplicated.</p>
<p>The two most common sources for artificial duplicates in Illumina data are: * PCR duplicates - They occur when the same fragment of DNA gets amplify multiple times during library preparation, often due to overamplification * Optical duplicates - They occur during sequencing when a single amplification fluorescent cluster is incorrectly detected as multiple clusters by the optical sensor of the sequencing instrument.</p>
<p><strong>NOTE:</strong> Duplicate marking is not always required! Some amplicon sequencing approaches will have sequencing reads start at the same sites (the primer sites), and therefore could be marked as duplicates without representing errors. Also, in RNA-seq you would also expect high rates of sample duplication, and therefore is also not advised to remove duplicates (unless you have UMIs…)</p>
<p>Most tools for marking duplicates from BAM files use the 5’ coordinates and mapping orientations of each read (or read pair), including any clipping, gaps or insertions, finding all reads that share exact genomic coordinates. It then keeps the read with the highest quality, marking the rest as duplicates. Note that often reads are not removed, but a flag is added. That’s why we call it marking duplicates!</p>
<p>The most commonly used software for marking duplicates is Picard (also implemented within GATK). However, this tool requires a lot of memory and time. I prefer another implementation of the same algorithm within the software <code>Sambamba</code>.</p>
<section id="sambamba" class="level3">
<h3 class="anchored" data-anchor-id="sambamba">Sambamba</h3>
<p>Sambamba takes a bam file as input and outputs a bam file where the read flag has been changed in some reads to reflect they are a duplicate. You can run sambamba as:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">sambamba</span> markdup <span class="co"># Main call to the duplicate marking function</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">--tmpdir=</span><span class="op">&lt;</span>temp_dir<span class="op">&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input.bam<span class="op">&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output.bam<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Unfortunately, <code>sambamba</code> (as <code>picard</code> and most tools for duplicate detection) require multiple passes of the input bam file, and therefore can’t read from stdin and be used in a pipe.</p>
<p>For a efficient and fast software that can be included within pipes, you can use <code>samtools markdup</code>. To run samtools markup you need to do a couple of operations to ensure proper read sorting and tagging:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> collate <span class="at">-Ou</span> <span class="op">&lt;</span>input_bam<span class="op">&gt;</span> <span class="kw">|</span> <span class="co"># Order reads by read-pairs</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> fixmate <span class="at">-m</span> <span class="at">-</span> <span class="at">-</span> <span class="at">-u</span> <span class="kw">|</span> <span class="co"># Add mate coordinates and score tags</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> sort <span class="at">-</span> <span class="at">-u</span> <span class="kw">|</span> <span class="co"># Order reads by coordinate</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ex">samtools</span> markdup <span class="at">-</span> <span class="op">&lt;</span>output_bam<span class="op">&gt;</span> <span class="co"># Mark duplicates</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This code can be pipped into your previous mapping command into one nice and efficient stream!</p>
</section>
</section>
<section id="long-read-mapping" class="level2">
<h2 class="anchored" data-anchor-id="long-read-mapping">Long-read mapping</h2>
<p>The most widely long-read mapper is <code>minimap2</code>, written by the same person who developed BWA, Heng Li. As BWA, the command line command to run it is quite simple:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">minimap2</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>reference_genome<span class="op">&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>long_reads.fastq.gz<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><code>minimap2</code> does not require you to provide an index, as it does it very efficienty on the fly.</p>
<p>A useful feature of <code>minimap2</code> is that it comes with some presets depending on the sequencing platform and the type of read. These presets take into account the typical read length and sequencing error profile for each technology.</p>
<section id="task-5-map-reads-to-the-reference-genome" class="level3">
<h3 class="anchored" data-anchor-id="task-5-map-reads-to-the-reference-genome">Task 5: Map reads to the reference genome</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Use <code>bwa mem</code> for short reads and <code>minimap2</code> for long-reads. For <code>minimap2</code>, choose the appropiate platform in the presets.</p>
<p>In both cases, create a pipe with the output of the mapper and samtools for coordinate sorting.</p>
<p>For the final output, any read that maps to chromosomes other than the chromosome you are working with should be considered ambiguous. Use the right command to keep only reads that mapped to your chromosome of interest.</p>
<ol type="1">
<li>Create a slurm array job to run the previous code. Attach your code to the assignment <strong>(10pts)</strong></li>
</ol>
</div>
</div>
</section>
</section>
</section>
<section id="variant-calling" class="level1">
<h1>Variant calling</h1>
<p>Variant calling is the process of identifying genetic differences between a reference genome and a sample. In our case, we aim to find differences between the mapped reads and the reference genome against which they are mapped. These variation can be of one nucleotide (single nucleotide polymorphism or SNP), small insertions or deletions (indels), or bigger structural variants (copy number variation, insertions, deletions, duplications, inversions, etc.).</p>
<p>For this assignment, we will focus only on SNPs.</p>
<p>A non-exhaustive list of popular variant callers both for short- and long-reads include:</p>
<p>Short-reads:</p>
<ul>
<li>BCFtools</li>
<li>GATK</li>
<li>FreeBayes</li>
<li>Deepvariant</li>
</ul>
<p>Long-reads:</p>
<ul>
<li>Longshot</li>
<li>Medaka</li>
<li>Clair3</li>
<li>Nanocaller</li>
<li>Deepvariant</li>
</ul>
<p>There are many variant callers out there and many bechmark studies. Just be careful to understand what each variant caller is doing and why they may differ in their output.</p>
<section id="variant-calling-in-short-reads---bcftools" class="level2">
<h2 class="anchored" data-anchor-id="variant-calling-in-short-reads---bcftools">Variant calling in short-reads - BCFtools</h2>
<p>For Illumina reads, we will use BCFtools for SNP calling.</p>
<p>Bcftools is ran in two steps. First, we create a pileup of the alignment. A pileup is a file where aligned reads are parsed and summarized at each specific genomic position. Thus, each genomic position is scanned and reads that spanned that position are gathered (piled up!), summarizing that position with metrics such as read depth, base quality, position bias, etc. It’s basically like finding variants but without applying any specific model. Many variant calling tools use some sort of pileup, even if they don’t do it explicitly as bcftools. Typically, the output of the pileup will be pippeted to bcftools variant calling function, which applies a model to calculate the likelihood of a variant and a genotype, given the pileup at that position. Variants are often stored in a Variant Calling Format (VCF) file.</p>
<p>To run the pileup and bcftools for variant discovery:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> mpileup <span class="co"># Pileup function</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-f</span> <span class="op">&lt;</span>reference_genome<span class="op">&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-a</span> AD,INFO/AD,ADF,INFO/ADF,ADR,INFO/ADR,DP,SP <span class="co"># Add tags useful for filtering</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ex">-q</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Skip reads with read quality below n</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="ex">-Q</span> <span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="co"># Skip bases with base quality below n</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="ex">-Ou</span> <span class="co"># Uncompressed output</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input_bam<span class="op">&gt;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output_vcf<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Once the pileup is done, the second step involves running the actual variant calling model. The main variant calling function can be used as:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> call <span class="co"># Main bcftools call function</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-m</span> <span class="co"># Multiallelic calling method</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-Oz</span> <span class="co"># Output in compressed format</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>output.vcf.gz<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>After calling variants, the file needs to be normalized. Variant normalization ensures genetic variants are represented in a consistent way across different data sets.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> norm</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-f</span> <span class="op">&lt;</span>reference_genome<span class="op">&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-Oz</span> <span class="co"># Output in compressed format</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ex">-o</span> <span class="op">&lt;</span>output.vcf.gz<span class="op">&gt;</span> <span class="co"># Output file name</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input.vcf.gz<span class="op">&gt;</span> <span class="co"># Input file name</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>After calling and normalizing variants, we can soft-filter them to tag variants that we deem of low quality. Soft-filtering means that we won’t remove low-quality variants, we will just add a tag to them.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> filter <span class="co"># Main function</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ex">-m+</span> <span class="co"># Append filter tags to previous tags</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Then each tag is added depending on the condition tested, and we piped it to more filtering commands</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ex">-s</span><span class="st">'MinMQ'</span> <span class="co"># Tag to add</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="ex">-e</span> <span class="st">'INFO/MQ &lt; 20'</span> <span class="co"># Condition to add tag</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>input.vcf.gz<span class="op">&gt;</span> <span class="kw">|</span> <span class="co"># Input file name</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> filter <span class="at">-m+</span> <span class="at">-s</span><span class="st">'QUAL'</span> <span class="at">-e</span> <span class="st">'QUAL &lt; 20'</span> <span class="kw">|</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> filter <span class="at">-m+</span> <span class="at">-s</span><span class="st">'minAD'</span> <span class="at">-e</span> <span class="st">'FMT/AD[:1] &lt; 10'</span> <span class="kw">|</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"># ... as many filters as you want |</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> filter <span class="at">-m+</span> <span class="at">-s</span><span class="st">'minADF'</span> <span class="at">-e</span> <span class="st">'FMT/ADF[:1] &lt; 3'</span> <span class="kw">|</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="ex">-Oz</span> <span class="co"># Output in compressed format</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="ex">-o</span> <span class="op">&lt;</span>output.vcf.gz<span class="op">&gt;</span> <span class="co"># Output file name</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Many tools will require the VCF file to be indexed. This can be done as follows:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">tabix</span> <span class="at">-p</span> vcf <span class="op">&lt;</span>vcf_file<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="task-6-complete-the-variant-calling-command" class="level3">
<h3 class="anchored" data-anchor-id="task-6-complete-the-variant-calling-command">Task 6: Complete the Variant Calling command:**</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Pipe the commands <code>mpileup</code>, <code>call</code>, <code>norm</code> and <code>filter</code> into one command to stream from the input bam file to the final VCF output.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> mpileup <span class="kw">|</span> <span class="ex">...</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Use the commands following this instructions. You will have to look at the help for each command:</p>
<ul>
<li>For <code>bcftools mpileup</code>:
<ul>
<li>Use all reads regardless of mapping quality</li>
<li>Keep only bases with base quality higher or equal than 20</li>
</ul></li>
<li>For <code>bcftools call</code>:
<ul>
<li>Print variant sites only</li>
<li>Do not report indels</li>
<li>Keep all alternate alleles</li>
</ul></li>
</ul>
<p>Apply the following filter tags in <code>bcftools filter</code>:</p>
<ul>
<li>‘MinMQ’ for MQ lower than 20</li>
<li>‘QUAL’ for QUAL lower than 20</li>
<li>‘minAD’ for allele depth lower than 20</li>
<li>‘minADF’ for allele forward depth lower than 5</li>
<li>‘minADR’ for allele reverse depth lower than 5</li>
<li>‘MinDP’ for total depth lower than 50</li>
</ul>
</div>
</div>
<p>Your output should be a VCF with the same number of variants as before. Remember, we have not removed any variant, we have only added a filter tag in the FILTER column. Variants that pass all our filters will automatically be assigned the tag “PASS” in the FILTER column.</p>
</section>
</section>
<section id="long-read-variant-calling" class="level2">
<h2 class="anchored" data-anchor-id="long-read-variant-calling">Long-read variant calling</h2>
<p>Technically, there’s no need to use different software for long-read variant calling. However, many variant callers have been developed with long-reads in mind, and benchmarking studies show they can perform better than general variant callers. Also, long-read mapping is characterized by alignments full of small artefactual indels, which can make short-read variant callers struggle and take a long time.</p>
<section id="task-7-call-snps-against-the-human-reference-genome" class="level3">
<h3 class="anchored" data-anchor-id="task-7-call-snps-against-the-human-reference-genome">Task 7: Call SNPs against the human reference genome**</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>To be consistent between sequencing platforms, we will use a variant caller that’s platform agnostic (i.e: it’s not optimized for any especific sequencing technology or read type). We will use BCFtools.</p>
<p>You can choose any variant caller you prefer, but run the same caller for all three sequencing technologies (Illumina, PacBio HiFi, ONT). Use any filters you see necessary.</p>
<p>For this task, report your variant calling command and your choice of options and filters.</p>
<ol type="1">
<li>Create a slurm array job to run the SNP calling code. <strong>Call only SNPs.</strong> Attach your code to the assignment <strong>(5pts)</strong></li>
</ol>
</div>
</div>
</section>
</section>
</section>
<section id="benchmarking" class="level1">
<h1>Benchmarking</h1>
<p>There’re many metrics we can use to get an idea of how well a test (or our case, a sequencing technology) performs compared to a known result (a gold standard or a benchmarking dataset).</p>
<p>All the metrics we will use for this assignment rely on calculating the number of true positives, false positives, true negatives and false negatives. A helpful visualization of this metrics and the relationship between them is on the form of a confussion matrix (although in my opinion it helps to be less confussed!). A confusion matrix is a table layout resulting from the comparison of the known values and the observed values.</p>
<p><img src="sens_spec.png" class="img-fluid"></p>
<p>All these metrics are often also expressed as rates. To do that, you can follow these formulas:</p>
<span class="math display">\[\begin{align*}
TPR &amp;= \frac{TP}{\text{Actual Positive}} = \frac{TP}{TP + FN} \\
FNR &amp;= \frac{FN}{\text{Actual Positive}} = \frac{FN}{TP + FN} \\
TNR &amp;= \frac{TN}{\text{Actual Negative}} = \frac{TN}{TN + FP} \\
FPR &amp;= \frac{FP}{\text{Actual Negative}} = \frac{FP}{TN + FP}
\end{align*}\]</span>
<p>Another common metric used is the F1 score. The F1 score is the harmonic mean of the precision (positive predictive value) and recall (sensitivity).</p>
<span class="math display">\[\begin{align*}
F_1 = \frac{2}{\text{recall}^{-1} + \text{precision}^{-1}} = 2 \cdot \frac{\text{precision} \cdot \text{recall}}{\text{precision} + \text{recall}} = \frac{2TP}{2TP + FP + FN}
\end{align*}\]</span>
<p>For our benchmarking, we are mostly interested in TP, FP and FN. In fact, our number of True Negatives would be so high that it will distort our specificity. For that reason, in variant calling and many other fields, precision and recall are the most important metrics, alongisde the F1 score. Precision is also known as Positive Predictive Value and recall is the same as sensitivity. Specificity and sensitivity is more comomnly used in diagnostic tests, for example, where the TN hold important value.</p>
<p><strong>Note:</strong> There’s a wide misuse of the term specificity for PPV, which causes loads of confussion. So sometimes is better to avoid the terms sensitivity/specificity and stick to recall/precision when benchmarking. Sensitivity/Specificity are hugely important in other fields though.</p>
</section>
<section id="vcf-comparison" class="level1">
<h1>VCF comparison</h1>
<p>In order to benchmark the technologies for SNP calling, we need to compare our VCFs with the gold standard HG002 set of variants. The HG002 we will use is a compilation of validated variants against the GRCh38 human genome.</p>
<p>So the benchmarking is basically an operation of intersecting two VCF files to find commonalities and differences between them.</p>
<section id="task-8-benchmarking-metrics-from-vcf-file" class="level3">
<h3 class="anchored" data-anchor-id="task-8-benchmarking-metrics-from-vcf-file">Task 8: Benchmarking metrics from VCF file</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Match the definitions in the intersections column with the possible benchmarking metrics <strong>(5pts)</strong>.</p>
<ul>
<li>The intersections are between your sample VCF (Va) and the benchmarking VCF (Vb).</li>
<li>The possible metrics are False Positive, False Negative, True Positive, and True Negative</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>VCF intersection</th>
<th>Benchmark metric</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Va and Vb</td>
<td></td>
</tr>
<tr class="even">
<td>not Va and not Vb</td>
<td></td>
</tr>
<tr class="odd">
<td>Va and not Vb</td>
<td></td>
</tr>
<tr class="even">
<td>not Va and Vb</td>
<td></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>You can write your own script to do this. The basic operation would be the following:</p>
<ol type="1">
<li>Get variant position, allele and genotype for your sample (Va)</li>
<li>Get variant position, allele and genotype for HG002 gold standard (Vb)</li>
<li>Match variant position, allele, and genotype</li>
<li>Repeat for every variant</li>
</ol>
<p><strong>NOTE:</strong> Positions without variants (GT=0/0) will not be present in your VCF files, but you still need to account for them.</p>
<p>You can read VCF files as normal text files, since you know the format of a VCF file. Alternatively, you can use specific packages to help you parse the VCF files. A common package within Python is <code>pyvcf</code>. Within R, <code>vcfR</code> does the job.</p>
<p>You can also use already written software to do this. We are esentially finding intersections between two VCF files. A widely used software suite to do this is <code>bedtools</code>, which handles BED files but also BAM and VCF files and has endless tools (https://bedtools.readthedocs.io/en/).The one for the job would be <code>bedtools intersect</code>. Another piece of software you can use is <code>bcftools isec</code>.</p>
<p><strong>NOTE:</strong> Some of these tools may have behaviors you don’t expect. For instance, <code>bedtools</code> is a coordinate based software (bed file), so it won’t take into account allele, genotype or filtering information. <code>bcftools isec</code> is a little better in that respect, as it will use allele information for the intersection, but not genotype. That means a genotype 0/1 and 1/1 will be matched.</p>
<p>Before doing the matching, you may want to filter your VCF to:</p>
<ul>
<li>Remove non-variant sites (0/0)</li>
<li>Remove unseen alleles in the genotype</li>
<li>Remove non-pass variants</li>
</ul>
</section>
</section>
<section id="genome-wide-assessment-using-genomic-windows" class="level1">
<h1>Genome-wide assessment using genomic windows</h1>
<p>A common way to represent genomic events is using genomic windows. These events can be coverage, mutations, etc. In our case, we are interested in looking at the number of FP and FN along the genome. We use genomic windows because going position by position is overkilling, and most positions will show a value of 0 anyways. Also, by using genomic windows we are smoothing the result, which can in turn reveal trends in the data. The size of the window depends on the analysis performed. Fine scale patterns are better observed in smaller windows, while broad trends may require larger windows. You will also have to decide whether to use overlapping or non-overlapping windows.</p>
<p>A common approach to do this using bedtools:</p>
<ol type="1">
<li>Get your FP or FN into bed format.</li>
</ol>
<p>Bed format is a simple tab delimited file for genomic coordinates with no header. First column is the chromosome name, second is the coordinate start and third column is the coordinate end. Additional columns can be added with annotations. SNPs can be shown in bed files as follow:</p>
<p>chr1 1000 1001<br>
chr1 1050 1051<br>
chr1 2000 2001</p>
<p>There are many ways to do this, including custom <code>awk</code> commands. The thing to remember is that a bed file is 0-based and a VCF file is 1-based. This image can help understand the difference:</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin: 0 auto">
<figure class="figure">
<p><img src="single_nucleotide_or_variant.jpg" class="img-fluid figure-img"></p>
<figcaption>Source: https://www.biostars.org/p/84686/</figcaption>
</figure>
</div>
<p>To do this within <code>bcftools</code>, you can use the following command:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bcftools</span> query <span class="at">-f</span> <span class="st">'%CHROM\t%POS0\t%END\n'</span> <span class="op">&lt;</span>input.vcf<span class="op">&gt;</span> <span class="op">&gt;</span> <span class="op">&lt;</span>output.bed<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol start="2" type="1">
<li>Make genomic windows</li>
</ol>
<p>This are the windows that will be used for counting.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bedtools</span> makewindows <span class="at">-g</span> chr_size.txt <span class="at">-w</span> <span class="op">&lt;</span>window_size<span class="op">&gt;</span> <span class="op">&gt;</span> windows.bed</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co"># The -g file is a tab delimited file with the chromosome name in the first column and the chromosome size on the second column (chr\tsize). You can get this from the &lt;ref&gt;.fai index file. You can use the entire .fai file if you are analyzing the whole genome, but for this assignment you can just grab your chromosome of interest.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol start="3" type="1">
<li>Counting the overlaps</li>
</ol>
<p>Then we need to count overlaps between our features (FP or FN) and the windows we created.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ex">bedtools</span> intersect <span class="at">-a</span> windows.bed <span class="at">-b</span> false_positives.bed <span class="at">-wa</span> <span class="at">-c</span> <span class="op">&gt;</span> window_counts.bed</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># -wa retrieves the coordinates in -a that overlap with -b</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co"># -c counts the number of overlaps in each window</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="task-9-benchmarking-of-different-sequencing-technologies-for-snp-calling." class="level3">
<h3 class="anchored" data-anchor-id="task-9-benchmarking-of-different-sequencing-technologies-for-snp-calling.">Task 9: Benchmarking of different sequencing technologies for SNP calling.</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>The latest task consists of a comparison between the variant calls you obtained and the gold standard.</p>
<ol type="1">
<li>How many variants are called using each sequencing technology and how many are in the gold standard? <strong>(5pts)</strong></li>
<li>How many true positive, false positive and false negative variants are present from using the different sequencing technology? <strong>(5pts)</strong></li>
<li>Calculate the precision and recall for each sequencing technology <strong>(5pts)</strong></li>
<li>Calculate the F1 score for each sequencing technology <strong>(5pts)</strong></li>
<li>Make a grouped barplot of each metric and each sequencing technology. Group bars by sequencing technology. Make one plot for TP, FP, FN; and another plot for precision, recall and F1 score (in percentage) <strong>(10pts)</strong></li>
<li>Look at the distribution of false negatives and false positives along the genome per sequencing technology using a genomic window of 10kbp. Make a density plot or a histogram of FP and FN along the genome. X-axis is genome position as determined by the beginning of the window. Y-axis is the number of FP or FN. Is there any pattern in the distribution? Are there any areas with high FP and FN? Calculate recall, precision and F1 for each genomic window. Are there any areas with low recall/precision/F1? Give approximate genomic coordinates <strong>(20pts)</strong></li>
<li>Repeat the analysis using genomic windows of 10kpb and a 5000bp window overlap. You can find this in the <code>bedtools makewindows</code> command help. Repeat the plot of the previous question. How has the plot change? Is there any pattern in the distribution? Are there any areas with high FP and FN? Calculate recall, precision and F1 for each genomic window. Are there any areas with low recall/precision/F1? Give approximate genomic coordinates <strong>(20pts)</strong></li>
</ol>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/trgn-515\.github\.io\/course-website\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>